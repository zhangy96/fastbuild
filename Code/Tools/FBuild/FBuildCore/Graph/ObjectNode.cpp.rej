--- Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp
+++ Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp
@@ -237,7 +237,7 @@ ObjectNode::~ObjectNode()
     bool useCache = ShouldUseCache();
     bool useDist = GetFlag( FLAG_CAN_BE_DISTRIBUTED ) && m_AllowDistribution && FBuild::Get().GetOptions().m_AllowDistributed;
     bool useSimpleDist = GetCompiler()->SimpleDistributionMode();
-    bool usePreProcessor = !useSimpleDist && ( useCache || useDist || GetFlag( FLAG_GCC ) || GetFlag( FLAG_SNC ) || GetFlag( FLAG_CLANG ) || GetFlag( CODEWARRIOR_WII ) || GetFlag( GREENHILLS_WIIU ) || GetFlag( ObjectNode::FLAG_VBCC ) || GetFlag( FLAG_ORBIS_WAVE_PSSLC ) );
+    bool usePreProcessor = !useSimpleDist && ( useCache || useDist || GetFlag( FLAG_GCC ) || GetFlag( FLAG_SNC ) || ( GetFlag( FLAG_CLANG ) && useDist ) || GetFlag( CODEWARRIOR_WII ) || GetFlag( GREENHILLS_WIIU ) || GetFlag( ObjectNode::FLAG_VBCC ) || GetFlag( FLAG_ORBIS_WAVE_PSSLC ) );
     if ( GetDedicatedPreprocessor() )
     {
         usePreProcessor = true;
@@ -502,7 +502,12 @@ Node::BuildResult ObjectNode::DoBuildWithPreProcessor2( Job * job, bool useDeopt
     bool usePreProcessedOutput = true;
     if ( job->IsLocal() )
     {
-        if ( GetFlag( FLAG_CLANG | FLAG_GCC | FLAG_SNC ) )
+        if ( GetFlag( FLAG_CLANG ) )
+        {
+            usePreProcessedOutput = false;
+        }
+
+        if ( GetFlag( FLAG_GCC | FLAG_SNC ) )
         {
             // Using the PCH with Clang/SNC/GCC doesn't prevent storing to the cache
             // so we can use the PCH accelerated compilation
@@ -1890,6 +1904,41 @@ bool ObjectNode::BuildArgs( const Job * job, Args & fullArgs, Pass pass, bool us
             }
         }
 
+        // %5 -> FirstExtraFile
+        found = token.Find( "%5" );
+        if ( found )
+        {
+            AStackString<> extraFile;
+            if ( job->IsLocal() == false )
+            {
+                job->GetToolManifest()->GetRemoteFilePath( 1, extraFile );
+            }
+
+            fullArgs += AStackString<>( token.Get(), found );
+            fullArgs += job->IsLocal() ? GetCompiler()->GetExtraFile( 0 ) : extraFile;
+            fullArgs += AStackString<>( found + 2, token.GetEnd() );
+            fullArgs.AddDelimiter();
+            continue;
+        }
+
+        // %CLFilterDependenciesOutput -> file name Unreal Engine's cl-filter -dependencies param
+        // MSVC's /showIncludes option doesn't output anything when compiling a preprocessed file,
+        // so in that case we change the file name so that it doesn't override the file generated
+        // during preprocessing pass.
+        found = token.Find( "%CLFilterDependenciesOutput" );
+        if ( found )
+        {
+            AString nameWithoutExtension( m_Name );
+            PathUtils::StripFileExtension( nameWithoutExtension );
+
+            fullArgs += AStackString<>( token.Get(), found );
+            fullArgs += nameWithoutExtension;
+            fullArgs += pass == PASS_COMPILE_PREPROCESSED ? ".empty" : ".txt";
+            fullArgs += AStackString<>( found + 27, token.GetEnd() );
+            fullArgs.AddDelimiter();
+            continue;
+        }
+
         // cl.exe treats \" as an escaped quote
         // It's a common user error to terminate things (like include paths) with a quote
         // this way, messing up the rest of the args and causing bizarre failures.
